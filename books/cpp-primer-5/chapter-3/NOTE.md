# 3.1 命名空间的`using`声明   

域操作符（::）：编译器应从操作符左侧名字所显示的作用域中寻找右侧那个名字。  

使用`using`声明，则可以省略命名空间。  
```cpp
using namespace::name
```
例如`using std::cout;`。  
一旦声明了上述语句，就可以直接访问命名空间中的名字。  

**注意**：使用逗号，并且用一行声明所有命名空间名字，需要C++17才行。  

- 每个名字都需要独立的`using`声明  
- 头文件不应该包含`using`声明  


# 3.2 标准库类型 `string`  

```cpp
#include <string>
using std::string;
```

## 3.2.1 定义和初始化`string`对象  

| 初始化`string`对象的方式 |                                                             |
| ------------------------ | ----------------------------------------------------------- |
| `string s1`              | 默认初始化，`s1`是一个空串                                  |
| `string s2(s1)`          | `s2`是`s1`的副本                                            |
| `string s2 = s1`         | 等价于`s2(s1)`，`s2`是`s1`的副本                            |
| `string s3("value")`     | `s3`是字面值`"value"`的副本，除了字面值最后的那个空支字符外 |
| `string s3 = "value"`    | 等价于`s3("value")`，`s3`是字面值`"value"`的副本            |
| `string s4(n, c)`        | 把`s4`初始化为连续`n`个字符`c`组成的串                      |

### 直接初始化和拷贝初始化  

如果使用等号初始化一个变量，实际上执行的**拷贝初始化（copy initialization）**，编译器把等号右侧的初始值拷贝到新创建的对象中去。  
与之相反，如果不使用等号，则执行的是**直接初始化（direct initialization）**。  

## 3.2.2 `string`对象上的操作  

| `string`的操作   |                                                              |
| ---------------- | ------------------------------------------------------------ |
| `os << s`        | 将`s`写到输出流`os`当中，返回`os`                            |
| `is >> s`        | 从`is`中读取字符串赋给`s`，字符串以空白分隔，返回`is`        |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is`                            |
| `s.empty()`      | `s`为空返回`true`，否则返回`false`                           |
| `s.size()`       | 返回`s`中字符的个数，类型是`size_type`                       |
| `s[n]`           | 返回`s`中第`n`个字符的**引用**，位置`n`从0计起               |
| `s1 + s2`        | 返回`s1`和`s2`连接后的结果                                   |
| `s1 = s2`        | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1 == s2`       | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1 != s2`       |                                                              |
| `<, <=, >, >=`   | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |

## 3.2.3 处理`string`对象中的字符  

使用`cctype`头文件函数处理单个字符的一些判断。  

> **注意**：C++ 兼容了C语言的标准库，C语言的头文件形如 *name.h*，而C++ 则将这些文件命名为 *cname*，去掉了`.h`后缀并且在 *name* 前添加字母*c*。  
> 对于C++ 程序员来讲，应该尽量用C++ 的头文件，因为这些标准库名字都能在命名空间`std`中找到，如果使用了C语言头文件，则不知道哪些是C语言继承过来的，哪些是C++ 独有。  

### cctype头文件中的函数  

| 函数名        | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| `isalnum(c)`  | 当 *c* 是字母或数字时为真                                    |
| `isalpha(c)`  | 当 *c* 是字母时为真                                          |
| `iscntrl(c)`  | 当 *c* 是控制字符时为真                                      |
| `isdigit(c)`  | 当 *c* 是数字时为真                                          |
| `isgraph(c)`  | 当 *c* 不是空格但可打印时为真                                |
| `islower(c)`  | 当 *c* 是小写字母时为真                                      |
| `isprint(c)`  | 当 *c* 是可打印字符时为真（即 *c* 是空格或具有可视形式）     |
| `ispunct(c)`  | 当 *c* 是标点符号时为真（即 *c* 不是控制字符、数字、字母、可打印空白中的一种） |
| `isspace(c)`  | 当 *c* 是空白时为真（即 *c* 是空格、横向制表符`\t`、纵向制表符`\v`、回车符`\r`、换行符`\n`、换页`\f`中的一种） |
| `isupper(c)`  | 当 *c* 是大写字母时为真                                      |
| `isxdigit(c)` | 当 *c* 是十六进制数字时为真                                  |
| `tolower(c)`  | 如果 *c* 是大写字母，输出对应的小写字母；否则原样输出 *c*    |
| `toupper(c) ` | 如果 *c* 是小写字母，输出对应的大写字母；否则原样输出 *c*    |

### 使用基于范围的`for`语句遍历字符串所有字符  

```cpp
// for (declaration : expression)
//     statement

string str("some string");
for (auto c : str)
    cout << c << endl;

```

### 使用范围`for`语句改变字符串中的字符  

```cpp
string s("Hello World!!!");
// 转换成大写形式
for (auto &c : s)     // 注意：c 是引用
    c = toupper(c);

cout << s << endl;
```

### 使用`[]`下标运算符获取一部分字符或者随机访问  

**下标运算符**（`[]`）的下标是从0开始，并且小于`s.size()`。例如：`s[0]`。  

可以使用下标进行迭代：  
```cpp
// 依次处理 s 中的字符直至处理完全部字符或遇到一个空白
for (decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++ index)
    s[index] = toupper(s[index]);
```

# 3.3 标准库类型`vector` 

`vector`表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。  
`vector`通常也被称为**容器**（container）。  

需要声明：  
```cpp
#include <vector>
using std::vector;
```

**模板简介**：  
- C++ 既有类模板也有函数模板，`vector`是一个类模板。  
- 模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数写的一份说明。  
- 编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应该把类型或函数实例化成何种类型。即`vector<int>`是一种类型，而`vector`不是。  
- 引用不是对象，不能作为`vector`元素。  

## 3.3.1 定义和初始化`vector`对象  

初始化`vector`对象的方法：  
| 方法                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `vector<T> v1`                | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)`            | `v2`中包含有`v1`所有元素的副本                               |
| `vector<T> v2 = v1`           | 等价于`v2(v1)`，`v2`中包含有`v1`所有元素的副本               |
| `vector<T> v3(n, val)`        | `v3`包含了`n`个重复的元素，每个元素的值都是`val`             |
| `vector<T> v4(n)`             | `v4`包含了`n`个重复地执行了值初始化的对象。如果`T`是内置类型，则对应内置类型的初值；如果是类类型，则执行默认初始化 |
| `vector<T> v5 {a, b, c...}`   | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
| `vector<T> v5 = {a, b, c...}` | 等价于`v5 {a, b, c...}`                                      |


**注意**：大多数情况下C++语言的几个初始化值方式可以相互等价地使用，但是有几种特殊情况：  
1. 使用拷贝初始化是（即使用`=`时），只能提供一个初始值；  
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化；  
3. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。如：  
    ```cpp
    vector<string> v1 {"a", "b", "a"};  // 列表初始化
    vector<string> v2 ("a", "b", "c");  // 错误！！
    ```

对于`vector`初始化只提供容纳元素个数时，库会给每个元素做值初始化，但是有两个限制：  
1. 有些类要求必须明确地提供初始值，如果`vector`对象中元素的类型不支持默认初始化，就必须提供初始的元素值；  
2. 如果只提供了元素的数量而没有设定初始值，只能使用**直接初始化**，即`vector<int> v(10)`，而不是`vector<int> v = 10; // 错误！！！`。  


### 列表初始值还是元素数量？  

初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。  

- 对于圆括号初始化，有以下两个含义：
    1. 初始化`vector`元素数量，`vector<int> v(10); // v有10个元素，每个元素值为0`  
    2. 初始化`vector`元素数量并且给每个元素一个初始值，`vector<int> v(10, 1); // v有10个元素，每个元素值为1`  

- 对于花括号，初始化过程会尽可能把花括号值当成是元素初始值的列表来处理，只有在无法执行列表初始化的时候才考虑其他初始化方式，如构造`vector`对象（会调用`vector`对象的构造函数）。如下所示：  
    ```cpp
    vector<string> v1 {"hi"}; // 列表初始化，v1有一个元素并且元素值为"hi"
    vector<string> v2("hi");  // 错误：不能使用字面值构造vector对象 
    vector<string> v3 {10};   // v3有10个元素，每个元素都是默认初始化，即空字符串 
    vector<string> v4 {10, "hi"} // v4有10个元素，值都是"hi"
    ```

## 3.3.2 向`vector`对象中添加元素  

`vector`对象能高效的增长，这点对于C和Java里面的使用不一样，C和Java里使用数组或者列表时，最好预先知道大小，这样能避免后面添加元素的时候影响性能，而`vector`则恰恰相反。  

使用`push_back`成员函数添加元素到`vector`尾端。  

对添加元素有几个注意点：  
1. 确保所写的循环正确无误，特别是在循环有可能改变`vector`对象容量时；  
2. 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围`for`循环。**范围`for`语句体内不应改变其所遍历序列的大小**；  
3. 还有更多，后续再添加...  


## 3.3.3 其他`vector`操作  

除了`push_back`之外，`vector`还支持以下操作：  

| 操作                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `v.empty()`            | 如果`v`不含有任何元素，返回真；否则返回假                    |
| `v.size()`             | 返回`v`中元素的个数                                          |
| `v.push_back(t)`       | 向`v`尾端添加一个值为`t`的元素                               |
| `v[n]`                 | 返回`v`中第n个位置上元素的引用                               |
| `v1 = v2`              | 用`v2`中元素的拷贝替换`v1`中的元素                           |
| `v1 = {a,b,c...}`      | 用列表中元素的拷贝替换`v1`中的元素                           |
| `v1 == v2`, `v1 != v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `<`, `<=`, `>`, `>=`   | 顾名思义，以字典顺序进行比较                                 |

**注意**：使用`v.size()`返回的是`vector<T>::size_type`，而不是`vector::size_type`。要谨记`vector<T>`才是一个类型。  

另外，无论是`vector`对象还是`string`对象，下标运算符都只能用于访问已存在的元素，而不能用于添加元素。  

对于`vector`对象的比较：  
1. 如果所有相同位置元素的值相同，则元素数量少的小于元素数量大的；  
2. 否则，根据顺序比较第一个相同位置下不相同元素的大小。  

### 关于`const vector`  

- `vector<const T> v` - 错误，`const T`不是[Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible)  
- `const vector<T> v` - `v`是不可以被修改的，并且元素的值也不能被修改  
- `const vector<const T> v` - 错误，与#1一样  

参考：[SO - Which is correct: vector\<const string\> OR const vector\<string\>?](https://stackoverflow.com/questions/21365331/which-is-correct-vectorconst-string-or-const-vectorstring)