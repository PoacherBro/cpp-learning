# 3.1 命名空间的`using`声明   

域操作符（::）：编译器应从操作符左侧名字所显示的作用域中寻找右侧那个名字。  

使用`using`声明，则可以省略命名空间。  
```cpp
using namespace::name
```
例如`using std::cout;`。  
一旦声明了上述语句，就可以直接访问命名空间中的名字。  

**注意**：使用逗号，并且用一行声明所有命名空间名字，需要C++17才行。  

- 每个名字都需要独立的`using`声明  
- 头文件不应该包含`using`声明  


# 3.2 标准库类型 `string`  

```cpp
#include <string>
using std::string;
```

## 3.2.1 定义和初始化`string`对象  

| 初始化`string`对象的方式 |                                                             |
| ------------------------ | ----------------------------------------------------------- |
| `string s1`              | 默认初始化，`s1`是一个空串                                  |
| `string s2(s1)`          | `s2`是`s1`的副本                                            |
| `string s2 = s1`         | 等价于`s2(s1)`，`s2`是`s1`的副本                            |
| `string s3("value")`     | `s3`是字面值`"value"`的副本，除了字面值最后的那个空支字符外 |
| `string s3 = "value"`    | 等价于`s3("value")`，`s3`是字面值`"value"`的副本            |
| `string s4(n, c)`        | 把`s4`初始化为连续`n`个字符`c`组成的串                      |

### 直接初始化和拷贝初始化  

如果使用等号初始化一个变量，实际上执行的**拷贝初始化（copy initialization）**，编译器把等号右侧的初始值拷贝到新创建的对象中去。  
与之相反，如果不使用等号，则执行的是**直接初始化（direct initialization）**。  

## 3.2.2 `string`对象上的操作  

| `string`的操作   |                                                              |
| ---------------- | ------------------------------------------------------------ |
| `os << s`        | 将`s`写到输出流`os`当中，返回`os`                            |
| `is >> s`        | 从`is`中读取字符串赋给`s`，字符串以空白分隔，返回`is`        |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is`                            |
| `s.empty()`      | `s`为空返回`true`，否则返回`false`                           |
| `s.size()`       | 返回`s`中字符的个数，类型是`size_type`                       |
| `s[n]`           | 返回`s`中第`n`个字符的**引用**，位置`n`从0计起               |
| `s1 + s2`        | 返回`s1`和`s2`连接后的结果                                   |
| `s1 = s2`        | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1 == s2`       | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1 != s2`       |                                                              |
| `<, <=, >, >=`   | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |

## 3.2.3 处理`string`对象中的字符  

使用`cctype`头文件函数处理单个字符的一些判断。  

> **注意**：C++ 兼容了C语言的标准库，C语言的头文件形如 *name.h*，而C++ 则将这些文件命名为 *cname*，去掉了`.h`后缀并且在 *name* 前添加字母*c*。  
> 对于C++ 程序员来讲，应该尽量用C++ 的头文件，因为这些标准库名字都能在命名空间`std`中找到，如果使用了C语言头文件，则不知道哪些是C语言继承过来的，哪些是C++ 独有。  

### cctype头文件中的函数  

| 函数名        | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| `isalnum(c)`  | 当 *c* 是字母或数字时为真                                    |
| `isalpha(c)`  | 当 *c* 是字母时为真                                          |
| `iscntrl(c)`  | 当 *c* 是控制字符时为真                                      |
| `isdigit(c)`  | 当 *c* 是数字时为真                                          |
| `isgraph(c)`  | 当 *c* 不是空格但可打印时为真                                |
| `islower(c)`  | 当 *c* 是小写字母时为真                                      |
| `isprint(c)`  | 当 *c* 是可打印字符时为真（即 *c* 是空格或具有可视形式）     |
| `ispunct(c)`  | 当 *c* 是标点符号时为真（即 *c* 不是控制字符、数字、字母、可打印空白中的一种） |
| `isspace(c)`  | 当 *c* 是空白时为真（即 *c* 是空格、横向制表符`\t`、纵向制表符`\v`、回车符`\r`、换行符`\n`、换页`\f`中的一种） |
| `isupper(c)`  | 当 *c* 是大写字母时为真                                      |
| `isxdigit(c)` | 当 *c* 是十六进制数字时为真                                  |
| `tolower(c)`  | 如果 *c* 是大写字母，输出对应的小写字母；否则原样输出 *c*    |
| `toupper(c) ` | 如果 *c* 是小写字母，输出对应的大写字母；否则原样输出 *c*    |

### 使用基于范围的`for`语句遍历字符串所有字符  

```cpp
// for (declaration : expression)
//     statement

string str("some string");
for (auto c : str)
    cout << c << endl;

```

### 使用范围`for`语句改变字符串中的字符  

```cpp
string s("Hello World!!!");
// 转换成大写形式
for (auto &c : s)     // 注意：c 是引用
    c = toupper(c);

cout << s << endl;
```

### 使用`[]`下标运算符获取一部分字符或者随机访问  

**下标运算符**（`[]`）的下标是从0开始，并且小于`s.size()`。例如：`s[0]`。  

可以使用下标进行迭代：  
```cpp
// 依次处理 s 中的字符直至处理完全部字符或遇到一个空白
for (decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++ index)
    s[index] = toupper(s[index]);
```

# 3.3 标准库类型`vector` 

`vector`表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。  
`vector`通常也被称为**容器**（container）。  

需要声明：  
```cpp
#include <vector>
using std::vector;
```

**模板简介**：  
- C++ 既有类模板也有函数模板，`vector`是一个类模板。  
- 模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数写的一份说明。  
- 编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应该把类型或函数实例化成何种类型。即`vector<int>`是一种类型，而`vector`不是。  
- 引用不是对象，不能作为`vector`元素。  

## 3.3.1 定义和初始化`vector`对象  

初始化`vector`对象的方法：  

| 方法                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `vector<T> v1`                | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)`            | `v2`中包含有`v1`所有元素的副本                               |
| `vector<T> v2 = v1`           | 等价于`v2(v1)`，`v2`中包含有`v1`所有元素的副本               |
| `vector<T> v3(n, val)`        | `v3`包含了`n`个重复的元素，每个元素的值都是`val`             |
| `vector<T> v4(n)`             | `v4`包含了`n`个重复地执行了值初始化的对象。如果`T`是内置类型，则对应内置类型的初值；如果是类类型，则执行默认初始化 |
| `vector<T> v5 {a, b, c...}`   | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
| `vector<T> v5 = {a, b, c...}` | 等价于`v5 {a, b, c...}`                                      |


**注意**：大多数情况下C++语言的几个初始化值方式可以相互等价地使用，但是有几种特殊情况：  
1. 使用拷贝初始化是（即使用`=`时），只能提供一个初始值；  
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化；  
3. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。如：  
    ```cpp
    vector<string> v1 {"a", "b", "a"};  // 列表初始化
    vector<string> v2 ("a", "b", "c");  // 错误！！
    ```

对于`vector`初始化只提供容纳元素个数时，库会给每个元素做值初始化，但是有两个限制：  
1. 有些类要求必须明确地提供初始值，如果`vector`对象中元素的类型不支持默认初始化，就必须提供初始的元素值；  
2. 如果只提供了元素的数量而没有设定初始值，只能使用**直接初始化**，即`vector<int> v(10)`，而不是`vector<int> v = 10; // 错误！！！`。  


### 列表初始值还是元素数量？  

初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。  

- 对于圆括号初始化，有以下两个含义：
    1. 初始化`vector`元素数量，`vector<int> v(10); // v有10个元素，每个元素值为0`  
    2. 初始化`vector`元素数量并且给每个元素一个初始值，`vector<int> v(10, 1); // v有10个元素，每个元素值为1`  

- 对于花括号，初始化过程会尽可能把花括号值当成是元素初始值的列表来处理，只有在无法执行列表初始化的时候才考虑其他初始化方式，如构造`vector`对象（会调用`vector`对象的构造函数）。如下所示：  
    ```cpp
    vector<string> v1 {"hi"}; // 列表初始化，v1有一个元素并且元素值为"hi"
    vector<string> v2("hi");  // 错误：不能使用字面值构造vector对象 
    vector<string> v3 {10};   // v3有10个元素，每个元素都是默认初始化，即空字符串 
    vector<string> v4 {10, "hi"} // v4有10个元素，值都是"hi"
    ```

## 3.3.2 向`vector`对象中添加元素  

`vector`对象能高效的增长，这点对于C和Java里面的使用不一样，C和Java里使用数组或者列表时，最好预先知道大小，这样能避免后面添加元素的时候影响性能，而`vector`则恰恰相反。  

使用`push_back`成员函数添加元素到`vector`尾端。  

对添加元素有几个注意点：  
1. 确保所写的循环正确无误，特别是在循环有可能改变`vector`对象容量时；  
2. 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围`for`循环。**范围`for`语句体内不应改变其所遍历序列的大小**；  
3. 还有更多，后续再添加...  


## 3.3.3 其他`vector`操作  

除了`push_back`之外，`vector`还支持以下操作：  

| 操作                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `v.empty()`            | 如果`v`不含有任何元素，返回真；否则返回假                    |
| `v.size()`             | 返回`v`中元素的个数                                          |
| `v.push_back(t)`       | 向`v`尾端添加一个值为`t`的元素                               |
| `v[n]`                 | 返回`v`中第n个位置上元素的引用                               |
| `v1 = v2`              | 用`v2`中元素的拷贝替换`v1`中的元素                           |
| `v1 = {a,b,c...}`      | 用列表中元素的拷贝替换`v1`中的元素                           |
| `v1 == v2`, `v1 != v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `<`, `<=`, `>`, `>=`   | 顾名思义，以字典顺序进行比较                                 |

**注意**：使用`v.size()`返回的是`vector<T>::size_type`，而不是`vector::size_type`。要谨记`vector<T>`才是一个类型。  

另外，无论是`vector`对象还是`string`对象，下标运算符都只能用于访问已存在的元素，而不能用于添加元素。  

对于`vector`对象的比较：  
1. 如果所有相同位置元素的值相同，则元素数量少的小于元素数量大的；  
2. 否则，根据顺序比较第一个相同位置下不相同元素的大小。  

### 关于`const vector`  

- `vector<const T> v` - 错误，`const T`不是[Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible)  
- `const vector<T> v` - `v`是不可以被修改的，并且元素的值也不能被修改  
- `const vector<const T> v` - 错误，与#1一样  

参考：[SO - Which is correct: vector\<const string\> OR const vector\<string\>?](https://stackoverflow.com/questions/21365331/which-is-correct-vectorconst-string-or-const-vectorstring)



# 3.4 迭代器介绍  

标准库容器都支持迭代器（iterator），但只有几个可以支持下标运算符。`string`不属于容器，只是可以容器类似的操作。  

类似于指针类型，迭代器提供了对对象的间接访问。其对象是容器中的元素或者`string`对象中的字符。  

迭代器有有效和无效之分（和指针类似）：  

- 有效的迭代器 - 指向某个元素，或者指向容器中尾元素的下一个位置；  
- 否则无效

## 3.4.1 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员函数，譬如`begin`和`end`两个成员函数就是返回迭代器。  

- `begin` - 成员函数，返回指向容器第一个元素（或第一个字符）的迭代器  
- `end` - 成员函数，返回指向容器最后一个元素（尾后元素）的下一个位置的迭代器（尾后迭代器）  
- 如果容器为空，则两者返回的是同一个迭代器  

迭代器支持以下操作符：  

- `*iter` - 返回迭代器`iter`所指元素的**引用**    
- `iter->mem` - 解引用`iter`并获取改元素的名为`mem`的成员，等价于`(*iter).mem`  
- `++iter`, `--iter`  
- `==`, `!=` - 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者他们是同一个容器的尾后迭代器，则相等；反之，不相等  

**注意**： `end`返回尾后迭代器并不实际指向某个元素，不能对它进行递增或解引用操作。  

### 迭代器类型

和不知道`vector`与`string`的`size_type`类型一样，一般来讲也不知道迭代器的精确类型。通过使用`iterator`和`const_iterator`来表示迭代器的类型：  

```cpp
vector<int>::iterator it;   // it能读写vector<int>的元素
string::iterator it2;       // it2能读写string对象中的字符

vector<int>::const_iterator it3;  // it3只能读元素，不能写元素
string::const_iterator it4;       // it4只能读元素，不能写元素
```

`begin`和`end`运算符返回的类型要看对象是否是常量，如果对象是常量，则返回`const_iterator`，否则返回`iterator`。  

C\+\+11新标准引入`cbegin`和`cend`函数，无论对象是否是常量，返回的都是`const_iterator`。  

### 某些对`vector`对象的操作会使迭代器失效  

- 不能在范围`for`循环中向`vector`对象增加元素  

- 任何一种改变`vector`对象容量的操作（譬如`push_back`），都是使该`vector`对象的迭代器失效  

  **任何使用了迭代器的循环体，都不要向迭代器所属的容器添加元素**  



## 3.4.2 迭代器运算

`string`和`vector`提供了更多额外的运算符：  

- `iter +/- n` - 迭代器加上或减去一个整数值，仍得到一个迭代器，迭代器指向的新位置与原来相比向前（+）或者向后（-）移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指向容器尾元素的下一位置  
- `iter += n`, `iter -= n` - 迭代器加法和减法复合赋值语句，将`iter`加或者键`n`的结果赋值给`iter`  
- `iter1 - iter2` - 两个迭代器相减的结果是它们之前的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或尾元素的下一个位置，返回类型是`difference_type`，一个带符号整型数  
- `>`、`>=`、`<`、`<=` - 迭代器关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置    



# 3.5 数组

数组是一种复合类型，默认声明为 `arr[d]`，必须声明维度 `d`，并且数组保持大小不变。维度必须是一个常量表达式。  

默认情况下，数组的元素被默认初始化。

**注意**：

- 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。
- 定义数组必须指定数组类型，不允许使用`auto`关键字由初始值的列表推断类型。  
- 数据的元素应为对象，不能用引用作为元素。  

## 3.5.1 定义和初始化内置数组  

- 可以对数据的元素进行列表初始化，此时允许忽略数组的维度  
    - 如果声明了维度，则列表长度不能超过数组维度；对于维度大于列表长度，则只会初始化靠前的元素，剩下的元素被初始化默认值  
    - 如果没有声明维度，则编译器会根据初始值的数量推测出来  
- 字符数组可以通过字符串字面值来初始化，但是需要注意**字符串字面值末尾还有一个空字符**    
- 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值  

注意字符数组的初始化 - 空字符：  
```cpp
char a1[] = {'a', 'b', 'c'};        // 列表初始化，没有空字符
char a2[] = {'a', 'b', 'c', '\0'};  // 列表初始化，含有显示的空字符
char a3[] = "C++";                  // 自动添加表示字符串结束的空字符
const char a4[3] = "Leo";           // 错误：没有空间存放空字符！！
```

> 一些编译器支持数组的赋值，这就是所谓的**编译器扩展**（compiler extension）。但一般来说，最好是避免使用非标准特性，因为在其他编译器很可能无法正常工作。  

### 理解复杂的数组声明  

```cpp
int *ptrs[10];             // ptrs 是含有10个整数型指针的数组
int &refs[10] = /* ？ */;  // 错误：不存在引用的数组
int (*Parray)[10] = &arr;  // Parray 指向一个含有10个整数的数组
int (&arrRef)[10] = arr;   // arrRef 引用一个含有10个整数的数组
```

默认情况下类型修饰符是**从右向左**一次绑定，但是对于数组而言，因为数组的维度是紧跟着被声明的名字的，所以**由内向外**要比从右向左更好。  

对于`Parray`，先看括号内，`*Parray` 意味着`Parray`是个指针，接下来看右边，可知道`Parray`是个指向大小为10的数组的指针，最后看左边，知道数组中的元素是`int`。  

## 3.5.2 访问数组  

可以通过范围`for`语句和下标运算符访问。数组的索引是从 0 开始。  

数组下表通常定义为`size_t`类型，一个与平台相关的无符号类型。  

注意下标越界问题，会导致缓冲区溢出。  

## 3.5.3 指针和数组

使用数组时编译器一般会把它转换成指针。大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。  
- 当使用数组作为一个`auto`变量的初始值时，推断得到的类型是指针而非数组  
    ```cpp
    int ia[] = {0, 1, 2, 3}; // ia是一个含有4个元素的数组
    auto ia2(ia);            // ia2是一个整型指针，指向ia的第一个元素
    ia2 = 42;                // 错误：ia2是一个指针，不能用int值给指针赋值
    ```
- 当使用`decltype`关键字时，上述转换不会发生。`decltype(ia)`返回的类型是由4个整数构成的数组  

### 指针也是迭代器

`vector`和`string`的迭代器支持的运算，**数组的指针**全部支持。  

- 通过下标运算符得到迭代器的首元素和尾后元素，很容易出错！！！
    ```cpp
    int *beg = ia;      // 第一个元素
    int *last = &ia[4];  // 尾后元素，不存在的元素。不能对它进行递增或解引用操作
    ```
- C\+\+11通过标准库函数`begin`和`end`获取首元素和尾后元素（定义在`iterator`头文件中）  
    ```cpp
    int *beg = begin(ia);
    int *last = end(ia);
    ```

**注意**：尾后指针不能做递增和解引用操作。  

### 指针运算

指向数组的指针也可以执行解引用、递增、比较、与**整数**相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。  

解引用时最好在必要的地方加上括号，避免运算错误。  
譬如：
```cpp
int last = *(p + 4); // 指的是数组第5个元素的值
int last = *p + 4;   // 值的是数组第1个元素的值加上4
```

两个指针相减得到结果的类型是`ptrdiff_t`标准库类型，和`size_t`一样，也是定义在 *cstddef* 头文件中的机器相关的类型。  
因为差值可能为负，所以是带符号类型。  

注意：  
- 与整数相加结果必须在数组范围内或指向尾后元素，否则会产生错误，且这种错误编译发现不了。  
- 两指针相减，必须是指向同一个数组的元素，或者是尾后元素。  

> 指针运算也可以适用于空指针和所指对象并非数组的指针。  
> - 如果是空指针，允许加上或减去一个值为0的整型常量表达式  
> - 如果非数组指针，则两个指针必须指向同一个对象或该对象的下一位置  
> - 两个空指针相减，结果当然是0  

### 下标和指针

在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针，在使用下表运算时，编译器会自动执行这个转换操作。  

只要指针指向的是数组中的元素（或者尾元素的下一位置），都可以执行下标运算。  
```cpp
int *p = &ia[2];  // p指向索引为2的元素
int j = p[1];     // p[1]等价于 *(p + 1)，就是ia[3]表示的那个元素
int k = p[-2];    // p[-2]是ia[0]表示的那个元素
```

**注意**：内置的下标运算符所用的索引不是无符号类型，这点和`string`、`vector`不一样。当然，内置的下标运算符远算结果地址必须指向原来的指针所指同一个数组中的元素（或同一数组尾后元素的下一位置）。



## 3.5.4 C 风格字符串

C 风格字符串是C\+\+ 继承自 C，并且是以字符串字面值这种通用结构。它不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。

字符串放在字符数组中并以**空字符结束**（null terminated）。一般以指针来操作这些字符串。

**注意**：尽管C\+\+支持C风格字符串，但在C\+\+程序里最好是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。  

C标准库`string`函数，头文件 *cstring* 中。

- `strlen(p)` - 返回字符串 `p` 的长度，空字符不计算在内
- `strcmp(p1, p2)` - 比较 `p1` 和 `p2`的相等性。如果 `p1 == p2` ，返回0；如果 `p1 > p2`，返回一个正值；如果 `p1 < p2`，返回一个负值
- `strcat(p1, p2)` - 将 `p2` 附加到 `p1` 之后，返回 `p1`
- `strcpy(p1, p2)` - 将 `p2` 拷贝给 `p1`，返回 `p1`

这几个函数都不会验证字符串参数，**必须保证传入的 `p` 是以空字符结尾**，否则会出现错误。

> 对于大多数应用来说，使用标准库 `string` 要比使用C风格字符串更安全、更高效。



## 3.5.5 与旧代码的接口

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：  
- 允许使用以空字符结束的字符数组来初始化`string`对象或为其赋值  
- 在`string`对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在`string`对象的符合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象  

**上述性质反过来就不成立**。  
```cpp
string str = "hello" + "world"; // 错误：不能用两个以空字符结束的数组做+运算
string str1;
str1 += "hello"                 // str1是"hello"

char *str2 = str1;              // 错误：不能用 string 对象初始化 char*
const char *str2 = str1.c_str() // 正确
```

不能确保`c_str()`返回的数组一直有效，如果函数执行完后想一直都能使用其返回的数组，最好将该数组重新拷贝一份。  

### 用数组初始化 `vector` 对象  

```cpp
int int_arr[] = {0, 1, 2, 3, 4, 5};
// ivec 有6个元素，分别是int_arr中对应的元素的副本
vector<int> ivec(begin(int_arr), end(int_arr));

// 也可以用数组一部分初始化
// 拷贝三个元素：int_arr[1], int_arr[2], int_arr[3]
vector<int> subVec(int_arr + 1, int_arr + 4);
```

其实是把数组转换成迭代器来初始化`vector`对象，切区间为[begin, end)。  

# 3.6 多维数组

严格来说，C\+\+语言中没有多维数组，通常所说的多维数组其实是**数组的数组**。  

当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小。

### 多维数组初始化

允许使用大括号来初始化多维数组，有几种方式：

```cpp
int ia[3][4] = {    // 三个元素，每个元素都是大小为4的数组
    {0, 1, 2, 3},   // 第一行的初始值
    {4, 5, 6, 7},   // 第二行的初始值
    {8, 9, 10, 11}  // 第三行的初始值
};

// 没有标识每行的花括号，与之前的初始化语句是等价的
int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};

// 显示地初始化每行的首元素，其他未列出值执行默认值初始化，为0
int ia[3][4] = { { 0 }, { 4 }, { 8 }};

// 显示地初始化第一行，其他元素执行默认值初始化，为0
int ia[3][4] = {0, 3, 6, 9};
```

### 多维数组的下标引用

使用下标运算符访问多维数组的元素，此时数组的每个维度对应一个下标运算符。

- 如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；  
- 如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组；  
- 如果数量大，则是错误。  

### 使用范围`for`语句处理多维数组

要使用范围`for`语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。这是为了**避免数组自动转成指针**。  

### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

```cpp
int ia[3][4];
int (*p)[4] = ia;   // p指向含有4个整数的数组
p = &ia[2];         // p指向ia的尾元素

// 注意圆括号，并且采用从内向外，再从右到左的阅读方式
// 如果没有圆括号，如下所示，这是代表一个含有4个整型指针的数组
int *p[4];  // 整型指针数组
```

通过使用`auto`和`decltype`就能尽可能避免在数组前面加上指针类型了。

### 类型别名简化多维数组的指针

```cpp
using int_array = int[4];   // 新标准下类型别名的声明
typedef int int_array[4];   // 等价的typedef声明
```

