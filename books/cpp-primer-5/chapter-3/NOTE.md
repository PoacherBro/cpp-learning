# 3.1 命名空间的`using`声明   

域操作符（::）：编译器应从操作符左侧名字所显示的作用域中寻找右侧那个名字。  

使用`using`声明，则可以省略命名空间。  
```cpp
using namespace::name
```
例如`using std::cout;`。  
一旦声明了上述语句，就可以直接访问命名空间中的名字。  

**注意**：使用逗号，并且用一行声明所有命名空间名字，需要C++17才行。  

- 每个名字都需要独立的`using`声明  
- 头文件不应该包含`using`声明  


# 3.2 标准库类型 `string`  

```cpp
#include <string>
using std::string;
```

## 3.2.1 定义和初始化`string`对象  

| 初始化`string`对象的方式 |                                                             |
| ------------------------ | ----------------------------------------------------------- |
| `string s1`              | 默认初始化，`s1`是一个空串                                  |
| `string s2(s1)`          | `s2`是`s1`的副本                                            |
| `string s2 = s1`         | 等价于`s2(s1)`，`s2`是`s1`的副本                            |
| `string s3("value")`     | `s3`是字面值`"value"`的副本，除了字面值最后的那个空支字符外 |
| `string s3 = "value"`    | 等价于`s3("value")`，`s3`是字面值`"value"`的副本            |
| `string s4(n, c)`        | 把`s4`初始化为连续`n`个字符`c`组成的串                      |

### 直接初始化和拷贝初始化  

如果使用等号初始化一个变量，实际上执行的**拷贝初始化（copy initialization）**，编译器把等号右侧的初始值拷贝到新创建的对象中去。  
与之相反，如果不使用等号，则执行的是**直接初始化（direct initialization）**。  

## 3.2.2 `string`对象上的操作  

| `string`的操作   |                                                              |
| ---------------- | ------------------------------------------------------------ |
| `os << s`        | 将`s`写到输出流`os`当中，返回`os`                            |
| `is >> s`        | 从`is`中读取字符串赋给`s`，字符串以空白分隔，返回`is`        |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is`                            |
| `s.empty()`      | `s`为空返回`true`，否则返回`false`                           |
| `s.size()`       | 返回`s`中字符的个数，类型是`size_type`                       |
| `s[n]`           | 返回`s`中第`n`个字符的**引用**，位置`n`从0计起               |
| `s1 + s2`        | 返回`s1`和`s2`连接后的结果                                   |
| `s1 = s2`        | 用`s2`的副本代替`s1`中原来的字符                             |
| `s1 == s2`       | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1 != s2`       |                                                              |
| `<, <=, >, >=`   | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |

## 3.2.3 处理`string`对象中的字符  

使用`cctype`头文件函数处理单个字符的一些判断。  

> **注意**：C++ 兼容了C语言的标准库，C语言的头文件形如 *name.h*，而C++ 则将这些文件命名为 *cname*，去掉了`.h`后缀并且在 *name* 前添加字母*c*。  
> 对于C++ 程序员来讲，应该尽量用C++ 的头文件，因为这些标准库名字都能在命名空间`std`中找到，如果使用了C语言头文件，则不知道哪些是C语言继承过来的，哪些是C++ 独有。  

### cctype头文件中的函数  

| 函数名        | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| `isalnum(c)`  | 当 *c* 是字母或数字时为真                                    |
| `isalpha(c)`  | 当 *c* 是字母时为真                                          |
| `iscntrl(c)`  | 当 *c* 是控制字符时为真                                      |
| `isdigit(c)`  | 当 *c* 是数字时为真                                          |
| `isgraph(c)`  | 当 *c* 不是空格但可打印时为真                                |
| `islower(c)`  | 当 *c* 是小写字母时为真                                      |
| `isprint(c)`  | 当 *c* 是可打印字符时为真（即 *c* 是空格或具有可视形式）     |
| `ispunct(c)`  | 当 *c* 是标点符号时为真（即 *c* 不是控制字符、数字、字母、可打印空白中的一种） |
| `isspace(c)`  | 当 *c* 是空白时为真（即 *c* 是空格、横向制表符`\t`、纵向制表符`\v`、回车符`\r`、换行符`\n`、换页`\f`中的一种） |
| `isupper(c)`  | 当 *c* 是大写字母时为真                                      |
| `isxdigit(c)` | 当 *c* 是十六进制数字时为真                                  |
| `tolower(c)`  | 如果 *c* 是大写字母，输出对应的小写字母；否则原样输出 *c*    |
| `toupper(c) ` | 如果 *c* 是小写字母，输出对应的大写字母；否则原样输出 *c*    |

### 使用基于范围的`for`语句遍历字符串所有字符  

```cpp
// for (declaration : expression)
//     statement

string str("some string");
for (auto c : str)
    cout << c << endl;

```

### 使用范围`for`语句改变字符串中的字符  

```cpp
string s("Hello World!!!");
// 转换成大写形式
for (auto &c : s)     // 注意：c 是引用
    c = toupper(c);

cout << s << endl;
```

### 使用`[]`下标运算符获取一部分字符或者随机访问  

**下标运算符**（`[]`）的下标是从0开始，并且小于`s.size()`。例如：`s[0]`。  

可以使用下标进行迭代：  
```cpp
// 依次处理 s 中的字符直至处理完全部字符或遇到一个空白
for (decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++ index)
    s[index] = toupper(s[index]);
```
